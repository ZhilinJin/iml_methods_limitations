# Feature Importance

As in previous chapters already discussed, there exist a variety of methods that enable a better understanding of the relationship between features and the outcome variables, especially for complex machine learning models. For instance, Partial Dependence (PD) plots visualize the feature effects on a global, aggregated level, whereas Individual Conditional Expectation (ICE) plots unravel the average feature effect by analyzing individual observations, allowing to detect, if existing, any heterogeneous relationships. Yet, these methods do not provide any insights to what extent a feature contributes to the predictive power of a model - in the following defined as feature importance. This perspective becomes interesting when recalling that so far black-box machine learning models aim for predictive accuracy rather than for inference, and hence, it is persuasive to also establish agnostic-methods that focus on the performance dimension. In the following, the two most common approaches, Permutation Feature Importance (PFI) by @breiman2001random and Leave-One-Covariate-Out (LOCO) by @lei2018distribution, for calculating and visualizing a Feature Importance metric, are introduced. At this point, however, it is worth to clarify that the concepts of feature effects and feature importance can by no means be ranked but rather should be considered as mutual complements that enable the interpretability from different angles. After introducing the concepts of PFI and LOCO, a brief discussion of their interpretability but also its non-negligible limitations will follow.

## Permutation Feature Importance (PFI)

The concept of Permutation Feature Importance was first introduced by @breiman2001random and applied on a random forest model. The main principle is rather straightforward and easily implemented. The idea is as follows: When permuting the values of feature $j$, its explanatory power mitigates, as it breaks the association to the outcome variable $y$. Therefore, if the model relied on the feature $j$, the prediction error $e = L(y,f(X))$ of the model $f$ should increase when predicting with the "permuted feature" dataset $X_{perm}$ instead of with the "initial feature" dataset $X_{orig}$. The importance of feature $j$ is then evaluated by the increase of the prediction error which can be either determined by taking the difference $e_{perm} - e_{orig}$ or taking the ratio $e_{perm}/e_{orig}$. Note, taking the ratio can be favorable when comparing the result across different models. A feature is considered less important, if the increase in the prediction error was comparably small and the opposite if the increase was large. Thereby, it is important to note that when calculating the prediction error based on the permuted features there is no need to retrain the model $f$. Below, a respective PFI algorithm based on @fisher2018model is outlined. Note however, that their original algorithm has a slightly different specification and was adjusted here for general purposes.

**The Permutation Feature Importance algorithm based on Fisher, Rudin, and Dominici (2018):**

Input: Trained model $f$, feature matrix $X$, target vector $y$, error measure $L(y,f(X))$

1. Estimate the original model error $e_{orig} = L(y,f(X))$ (e.g mean squared error)
2. For each feature $j = 1,...,p$ do:
    * Generate feature matrix $x_{perm}$ by permuting feature j in the data $X$
    * Estimate error $e_{perm} = L(y,f(X_{perm}))$ based on the predictions of the permuted data,
    * Calculate permutation feature importance $PFI_{j} = e_{perm}/e_{orig}$. Alternatively, the difference can be used: $PFI_{j} = e_{perm} - e_{orig}$
3. Sort features by descending FI.

<br>
Below, it is illustrated, by a fictional, exemplary random forest model, how the permutation algorithm alters the original dataset. For each of the $M$ trees, the respectively permuted dataset is then used to first predict the outcomes and then calculate the prediction error. From the resulting differences in the prediction errors $\Delta e^{i}$, the average $\frac{1}{M}\sum_{i=1}^{M} \Delta e_{1}^{i} = PFI_{1}$ over all trees is calucated which can then be considered as the PFI of feature $j$.


<br>

```{r,out.width="50%", fig.ali, echo = FALSE, message = FALSE, fig.show="hold"}
knitr::include_graphics(c("images/Permutation_1.jpg","images/Permutation_2.jpg"))
```


<center>
$\hspace{0.5cm}\Delta e^{(1)} = L(y,f^{(1)}(X))- L(y,f^{(1)}(X_{\text{perm}}))\hspace{1.9cm}\Delta e^{(M)} = L(y,f^{(M)}(X))- L(y,f^{(M)}(X_{\text{perm}}))$
</center> 



<br>

To show, how the PFI for all features of a model can be visualized and thereby more conveniently compared, the PFI algorithm with a random forest model is applied on the dataset "Boston", which is available in R. To predict the house price, seven variables are included, whereby as the results show, the PFIs vary substantially across the variables. The depicted points correspond to the median PFIs over all shuffling iterations of one feature and the boundaries of the bands illustrate the 0.05- and 0.95-quantiles, respectively.  

<br>

<center>
```{r, echo = FALSE, message = FALSE, fig.height=6, fig.width=12}

library(iml)
library(ggplot2)
library(randomForest)

set.seed(040232359)
data("Boston", package = "MASS")
Boston <- Boston[,c(1,6,13,8,12,14,5,7)]
rf <- randomForest(medv ~ ., data = Boston, ntree = 50)
y = Boston$medv
X = Boston[-which(names(Boston) == "medv")]
mod = Predictor$new(rf, data = X, y = y)
  # Compute feature importances as the performance drop in mean absolute error
  imp = FeatureImp$new(mod, loss = "mae", n.repetitions = 5, compare = "ratio")
  # Plot the results directly
  imp.dat = imp$results

  imp.dat[which(imp.dat$feature == "rm"),]$feature <- "Rooms"
  imp.dat[which(imp.dat$feature == "lstat"),]$feature <- "Status of the Population"
  imp.dat[which(imp.dat$feature == "dis"),]$feature <- "Employment Centers Dist."
  imp.dat[which(imp.dat$feature == "crim"),]$feature <- "Crime Rate"
  imp.dat[which(imp.dat$feature == "nox"),]$feature <- "Nitric Oxides conc."
  imp.dat[which(imp.dat$feature == "age"),]$feature <- "Age"
  imp.dat[which(imp.dat$feature == "black"),]$feature <- "Blacks"

  
 p1 <- ggplot(data = imp.dat, aes(x = reorder(feature, importance), ymin=importance.05, ymax=importance.95)) + 
    geom_errorbar(width=0.3, size=1, color="darkblue") + 
    geom_point(mapping=aes(x=feature, y=importance), size=3, shape=21, fill="white") +
    coord_flip() +
    theme(plot.subtitle = element_text(size = 10)) +
    labs(y = "Feature Importance (ratio MAE)", x= "") + 
    theme(text = element_text(size = 16))
  
p1 
```
</center>

## Leave-One-Covariate-Out (LOCO)

The concept of Leave-One-Covariate-Out (LOCO) is as already mentioned a different approach to PFI with the same objective, to gain insights on the importance of a specific feature for the prediction performance of a model. Although applications of LOCO exist, where comparable to PFI, the initial values of feature $j$ are replaced by its mean, median or zero [see @hall2017ideas], and hence, circumvent the disadvantage of re-training the model $f$, the common approach follows the idea to simply leave the respective feature out. The overall prediction error of the re-trained model $f_{-j}$ is then compared to the prediction error resulted from the baseline model. However, re-training the model results in higher computational costs, becoming more severe with an increasing feature space. The pseudo-code shown below, illustrates the algorithm for the common case where the feature is left out. [see @lei2018distribution]

**The Leave-One-Covariate-Out algorithm based on Lei et al. (2018):**

Input: Trained model $f$, feature matrix $X$, target vector $y$, error measure $L(y,f(X))$

1. Estimate the original model error $e_{orig} = L(y,f(X))$ (e.g mean squared error)
2. For each feature $j = 1,...,p$ do:
    * Generate feature matrix $x_{-j}$ by removing feature j in the data $X$
    * Refit model $f_{-j}$ with data $X_{-j}$
    * Estimate error $e_{-j} = L(y,f_{-j}(X_{-j}))$ based on the predictions of the reduced data,
    * Calculate LOCO Feature Importance $FI_{j} = e_{-j}/e_{orig}$. Alternatively, the difference can be used: $FI_{j} = e_{-j} - e_{orig}$
3. Sort features by descending FI.


<br>


Below, it is shown, how the LOCO algorithm alters the original dataset, whereby it always differs, depending on the respective feature that is left out. Note, that the qualititative and quantitative interpretations correspond the ones from the PFI method. So do the visualization tools and therefore at this point it is refrained from providing the reader with an additonal real data example. 

<br>

```{r,out.width="70%", fig.align='center',echo = FALSE, message = FALSE}
knitr::include_graphics("images/LOCO_1.jpg")
```
<br>


<center>
$L(y,f(X))- L(y,f_{-1}(X_{-1}) =  \text{Feature Importance of }x_{1}$
<center>

...

```{r,out.width="70%", fig.align='center', echo = FALSE, message = FALSE}
knitr::include_graphics("images/LOCO_2.jpg")
```

<br>
<center>
$L(y,f(X) - L(y,f_{-p}(X_{-p})) = \text{Feature Importance of } x_{p}$
</center>


## Interpretability of Feature Importance and its Limitations


After both methods are discussed, the question to what extent these agnostic-methods can contribute to a more comprehensive interpretability of machine learning models will be now touched on. By doing so, it is necessary to also reflect upon the limitations of the model regarding the interpretability of the results. The latter will constitute the main focus in the following chapters. 
Conveniently, both methods are highly adaptable on whether using classification or regression models, as they are non-rigid towards the prediction error metric (e.g. Accuracy, Precision, Recall, AUC, Average Log Loss, Mean Absolute Error, Mean Squared Error etc.). This allows to assess Feature Importance based on different performance measures. Besides, the interpretation can be conducted on a high-level, as both concepts and  do consider neither the shape of the relationship between feature and outcome variable nor the direction of the feature effect. However, as illustrated in Figure XX, PFI and LOCO only return for each feature a single number and thereby neglect possible variations between subgroups in the data. Chapter XX will focus on how this limitation can be, at least for PFI, circumvented and introduces the concepts of Partial Importance (PI) and Individual Conditional Importance (ICI) which both avail themselves on the conceptual ideas of PD and ICE. Besides, limitations appear when some features in the feature space are correlated. If so, simply breaking the relationship between a feature and the outcome variable does not necessarily reveal the true Feature Importance as the explanatory power is shifted to the remaining, correlated feature, resulting in a weakened drop in the model performance. This can also result in an erroneous ranking and hence, in incorrect conclusions. Further, if correlation exists and only in case of applying the PFI method, permuting a feature can result in unrealistic data instances so that the model performance is evaluated based on data which is never observed in reality. This makes comparisons of prediction errors complicated and therefore it should always be checked for this problem, if applying the PFI method. Chapter XX will focus on this limitation by comparing the performance of PFI and LOCO for different models (e.g. linear models or random forest) and different levels of correlation in the data. Beyond these limitations, it is evident to also question whether these agnostic-meethods should be computed on training or test data. As answering that, depends highly on the research question and data, it is refrained to go in more detail at this point but will be examined and further discussed in chapter XX. 







