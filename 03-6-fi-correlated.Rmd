# PFI, LOCO and Correlated Features

The method of Feature Importance is a powerful tool to gain insights of black box models assuming that the features of the given dataset are uncorrelated with each other. However, this assumption can be most of the time neglected in reality. As mentioned in chapter 1 some model agnostic tools like the interpretability of PDPs suffer from correlated features. As well as for PDPs the interpretability of Feature Importance can depend on the correlations between the input variables. If all features of  a data set are independent and not correlated, you can can calculate the the feature importance of every feature and there is no problem in the interpretability due to correlation effects. Whereas if there are some correlated feature in the data which is highly possible in reality, then the results of the feature importance do not reflect the individually feature importance. This can lead to misleading ranking of the features and thus to wrong interpretations about the relevance of a feature in a model. 

There are two main problems when you are confronted with correlated features. The following two examples illustrate these issues. The first and most crucial one is the problem of misleading ranking of correlated features. By adding a correlated feature to the data set it can lead to a decrease in Feature Importance of the feature with which it is correlated. Imagine you want to predict the risk of a heart attack by looking at the weight of a person had yesterday and other uncorrelated features. For instances, you choose a random forest model and calculate the corresponding PFI. It is well know that overweight can be a deciding influence factor for heart attacks and your model as well indicating that weight is the most important feature. What happens if you now also add the weight of the person of today which is highly correlated to the weight of a person yesterday. A big advantage of a random forest model is the application and predictive accuracy of high dimensional data sets. Even in the case of correlated features or interaction effects. So adding a new component should be no problem. However, there can be some effects on the Feature Importance that can make an interpretation more difficult. Since, now the importance kind of splits between both features. During the training of the random forest, some of the decision trees will choose the weight of today, the the weight of yesterday, both or another none of these two as a split criteria.  

The second does seem to play a role in case of PFI. If the features are correlated it can happen in the step of shuffling on of the features that there are unrealistic instances of data points. In this case it breaks not only the association to the outcome variable, but also the association with the correlated feature. So there are cases where the new data points are unlikely all the way up to completely impossible. The question is can we still trust the informative value of the PFI, if it is calculated with data instances that are not observed in reality and therefore biased? In Figure \@ref(fig:realPFI02) illustrared an example with a possible outcome of unrealistic data instances.


```{r realPFI01,  eval = TRUE, echo = FALSE, fig.align = 'center', out.width = '75%'}
knitr::include_graphics("images/realPFI01.png")
```

```{r realPFI02,  eval = TRUE, echo = FALSE, fig.align = 'center', out.width = '75%', fig.cap = "The two tables showing a subset of the bike sharing data set we already know. The one on top shows the first six rows of the original data set using the function  `head()` in R. The table below are showing the first six rows of the data set where the feature `weakday` is shuffled. As you can see some of the new data instances make no sense. For instance in observation 1 Wednesday is claimed to be a no working day."}
knitr::include_graphics("images/realPFI01.png")
```

In this chapter we want to demonstrate some issue of correlated features and trie to present some reasons of the outcomes. It is not about to show all the problems, which would go beyond the scope of this chapter, but rather to make the reader aware of the problem, so that mistakes can be avoided in the future.

## Effect on Feature Importance by Adding Correlated Features

In this chapter we want to take a closer look at the problem of the interpretation of Feature Importance by adding or having correlated features in the given data set. Our focus lies on the behaviour of Permutation Feature Importance by Breiman as well as of the LOCO Feature Importance by Lei et. which have been already introduced. There will be a comparison of these measures apllied on different basic learners the random forest, support vector maschine and linear model with different correlation intesities.  Later on there is an application on a real data set `Boston`. 

### Simulation 

A good way to show the effects of correlated features on the feature importance measures is to simulate some data with the desired dependence. This allows us to show the effects on the PFI and LOCO feature Importance more precise than looking on a real data set where additional dependencies between each features exist and may falsify the results. To filter out the real effect it is neccessary to hold the influence of other features as small as possible, so there will be no misinterpretations. For the complete R Code please refer to .... 


This is done by looking at the behaviour of PFI and LOCO Feature Importance when the feature of the given data set are correlated with each other. To get a better understanding there will be a change in the intensity of the correlation of the features as well as in the complexity of the learning algorithms. The random forest is in this context a black box model (hard to interpret), the linear model a white boxx model (easy to interpret) and the sipport vector maschine something in between both. These algorithms should show a different behavior.

In total there will be ... different scenario settings to investigate the influence of correlated features on the PFI and LOCO. The following setup is used as a general baseline for the scenarios: 

$$
y_{i} = x_{i1}+x_{i2}+x_{i3}+x_{i4}+\epsilon_{i}
$$

**The simulation design of different correlation intensities**

In order to examine the effect we simulated a fictive data set with four features $x_{i1}...x_{i4}$ and a thousand observation $i = 1,...,1000$. The features were randomly drawn out of a multivariate gaussian distribution with a mean of 0 $X \sim MVN(0,\Sigma)$. The covariance $\Sigma$ depends on the variance of all features which were set equally to $\sigma_{j,j}=1$ and covariance $\sigma_{j,l}$. 

Here we want to investigate the effect on PFI and LOCO Feature Importance of the correlated features with different kind of dependencies on the target value y. There are four features of which two ($X1$ and $X2$) show different correlaion intensities $\rho$ betweeen each other. Otherwise, there is no correlation between any feature. 


The covariance for feature $X1$ and $X2$ $\sigma_{1,2}$ were set to either $\rho = 0$;$0,25$;$0,5$;$0,75$ or $0,99$ depending on our intesity of interest whereas the covariance of the rest were set to $\sigma_{j,l} = 0$ which means independence. Note: Here the correlaion and the covariance are the same, because we set the variance to 1 such that $\rho = \frac{Cov(X_{j},X_{l})}{\sqrt{Var(X_{j})}\sqrt{Var(X_{l})}} =Cov(X_{j},X_{l})$. The reason behind we setting $\rho = 0.99$ and not to $p=1$ is that to avoid problems to calculate matrices. If $\rho = 1$ we have perfect multicollinearity and the problem that the rank of the matrix is not full. So this simplifies later calculations especially regarding the application of the linear model.

The choice of noise $\epsilon_{i}$ and its variance should be hold small in order to make the behavior we observe clearer and there will be no misinterpretation. In this case we assume that there is only a standard deviation of ten percent of the mean of the [...].

Also including an uninformative feature ”Uninf” randomly drawn out of a uniform distribution to compare whether the importance of the features are higher than this random effect.

Quelle: Archer and Kimes, Strobl 2008

* added a random variable $Uinf$ to see if the importance is higher than a random effect

**How to compare PFI and LOCO?**

As mentioned in the introduction to this chapter PFI do not need to refit the model whereas for LOCO it is necessary to refit. In the `iml` package (by Molnar) the implementation uses Hold-out for performance evaluation. Typically Hold-out is quiet bad to evaluate the performance of a model unless the data record is sufficiently large. Since, the variance of the performance value is quiet high which means that the out coming performance vale can fluctuated a lot. To lower the variance of PFI the values are calculated by repeatedly shuffling of the feature in the permutation step. However, Hold-out is definitely not suitable for LOCO, because there are no reshuffling possible as the interested feature is completely left out of consideration. So the danger of high variance is to great. In contrast to Hold-out there exist Resampling methods which use the data more efficiently by repeatedly dividing the data into train and test data and aggregating the results. So in order to make the two approaches better comparable we use Subsampling (repeated Hold-out) for measuring the performance for PFI which means that we use PFI on test data. In this case a Subsampling with a 20-80% split (as recommended in the literature) and 10 iterations were used. The following visualizations are based on Feature Importance which are aggregated by the average over the 10 iterations of Subsampling. Furthermore, instead of taking the difference of model error and the estimated prediction error after permuting or leaving the feature out to calculate the Feature Importance of a feature $j$, the ratio is used. 


**1) Linear Dependence:**

In the first scenario setting the dependence of the features $X_i$ on the target value $y$ is a linear one: 


$$
y_{i} = x_{i1}+x_{i2}+x_{i3}+x_{i4}+\epsilon_{i}
$$


In order to get meaningful results one has to check whether the underlying model were proved to be accurate. In case your model does not generalize accurately the Feature Importance can vary greatly when rerunning the alogorithms and therefore the results are not significant. In Figure \@ref(fig:bmr01) there is a benchmark result over all learning algorithms used on the simulated data sets. As a performance measure we decided to show on the one hand the mean squared error (MSE), since is also used a Loss measure for evaluating the Feature Importance. The value should be a low a possible. On the other hand $R^2$ as it is a common measure for linear models and since we have a linear dependence of the features on the target value it makes sense to have a look at. A $R^2 = 1$ implies that all residuals are zero, so a perfect prediction. Whereas a $R^2 = 0$ means that we predict as bad as a constant. As you can see in Figure \@ref(fig:bmr01) all learning algorithms have very good up to perfect results in other words are accurate. The random forest is considered as the worst of the algorithms at hand. That is not suprising as the random forest is not the best learning algorithm if the true prediction function is linear, since it learns multiple decision trees which implies multiple step functions. The linear model is by far the best which makes absolut sense as we have a linear dependence.


```{r bmr01, echo=FALSE, out.width='100%', fig.cap="Benchmark of Scenario 1", fig.align='center'}
knitr::include_graphics('images/bmr01.png', auto_pdf = getOption("knitr.graphics.auto_pdf", TRUE))
``` 






 



```{r PFI01, message = FALSE, echo = FALSE, fig.height=6, fig.width=12, fig.cap= "PFI with different correlations of features 1 and 2 on a random forest model"}
library(ggplot2)
load("data/drfPFI.RData")

prferr <- ggplot(data = drfPFI, aes(x=features, y= importance, colour = Corr, ymin= minimp, ymax=maximp)) + 
  geom_point(fill = "white",size=0, shape=21 , 
             stroke= 2.5, show.legend = TRUE, position = position_dodge(width = 0.6)) +
  geom_errorbar(width=0.5, size=1, position = position_dodge(width = 0.6)) + 
  coord_flip() +
  scale_colour_manual(values=c("0" = "skyblue", "0.25" = "royalblue", "0.5"= "blue",
                               "0.75"="navy", "0.99" = "black"))+
  scale_fill_manual(values=c("0" = "skyblue", "0.25" = "royalblue", "0.5"= "blue",
                             "0.75"="navy", "0.99" = "black"))+
  theme(plot.subtitle = element_text(size = 9), text = element_text(size = 14), legend.position="bottom") +
  labs(y = "PFI (Loss: MSE)", x= "") + 
  ylim(0,10)

```



```{r PFIrank01, message = FALSE, echo = FALSE, fig.height=6, fig.width= 8, fig.cap= "PFI with different correlations of features 1 and 2 on SVM"}
library(ggplot2)
load("data/drfPFI.RData")

prfrank01 <- ggplot(drfPFI, aes(x=averagerank , y=Corr, colour = features, group= features)) +
  geom_point(size=2)+
  geom_path(aes(group=features), size=1)+
  coord_flip() +
  scale_colour_manual(values = c("Uninf" = "#999999", "X1" = "darkred", "X2"= "red",
                               "X3"="#006600", "X4" = "#33CC33"))+
  scale_x_reverse()+
  geom_vline(xintercept = 2.5, linetype="dashed")+
  theme(legend.position="bottom", plot.subtitle = element_text(size = 9), text = element_text(size = 14))

```



```{r arrange01, message = FALSE, echo = FALSE, fig.height=6, fig.width=10, fig.cap= "PFI with different correlations of features $X1$ and $X2$. The underlying learning algorithm is the random forest. The left plot shows the PFI values for different correlation intesities. The right plot represetnts the average rank of the features at a certain correlation intesity. The red lines marking the two correlated features and the green ones the independent. The dashed line is the complete average rank over all features when all of them has the exact same value. The line is used as a indicator how far away certain features are away from their actual influence"}
library(ggpubr)
ggarrange(prferr, prfrank01 , ncol=2, legend = "bottom", widths = c(2, 1))

```

Figure \@ref(fig:arrange01) shows the result of applying the PFI on the random forest model. The plot on the left hand side shows the average value (the point) as well as it presents the 0.05- and 0.95 qauntiles over the 10 subsampling iterations, respectively. In addition, the plot on the right hand side shows the average importance rank based on the 10 subsampling iteration. It is important to mention that typically the Feature Importance can only be interpreted in a rank order than really based on the values. One can see that in case of independence the PFI of all features are round about the same except for the uninformative one. Since the uninofrmative indicated a complete random effect, one can suggest that all features $X_{i}$ have an influence on the performance of the model. Overall the PFI of the correlated features $X1$ and $X2$ tend to increase more in comparison to the uncorrelated features as $\rho$ increases. Moreover, the span of the qunatile bands increases with higher $\rho$. This effect can also be seen in the other plot. For independence, all points are near the average of 2.5 rank. The fluctuations can be explained by the underlying stochastic. However, from a correlation higher than 0.5  we see a gap between the correlated features in red colour and the uncorrelated in green colour. The correlated features settle down at an average rank of about 1.5 and the uncorrelated about 3.5. 


  
```{r exp, message = FALSE, echo = FALSE ,fig.height=6, fig.width=12, fig.cap="PFI with different correlations of features 1 and 2 on a linear model"}
library(ggplot2)
library(mlr)
load("data/exp.RData")
load("data/exptask.RData")

exp <- plotLearnerPrediction(rf_learner, extrapolation_task)+
        geom_segment(aes(x = -2, y = -2, xend = 2.3, yend = -2),color="white",size=1.2,
                arrow = arrow(length = unit(0.5, "cm")))+
          geom_point(aes(x = 2.5, y=-2), colour="blue")

```


```{r exp01, message = FALSE, echo = FALSE ,fig.height=6, fig.width=12, fig.cap="PFI with different correlations of features 1 and 2 on a linear model"}
library(ggplot2)
library(mlr)
load("data/exp01.RData")
load("data/exptask01.RData")

exp01 <- plotLearnerPrediction(rf_learner01, extrapolation_task01)+
  geom_segment(aes(x = -2, y = -2, xend = 2.3, yend = -2),color="white",size=1.2,
               arrow = arrow(length = unit(0.5, "cm")))+
  geom_point(aes(x = 2.5, y=-2), colour="blue")
  

```


```{r arrangeexp, message = FALSE, echo = FALSE, fig.height=6, fig.width=10, fig.cap= "PFI with different correlations of features 1 and 2 on SVM"}
library(ggpubr)
ggarrange(exp01, exp, ncol=2, legend = "bottom")

```

Altough all features have the same influence on the target value, one can see that PFI can be misleading as it shows a higher PFI rank the higher the correlation between two features. One possible explanation is given by .... 
They state that the main reason behind this effect is caused by extrapolation which we already mentioned in the context of problems with PDPs. A small recap, extrapolation is the process of estimating beyond the distribution of our original data set. Figure \@ref(fig:arrangeexp) shows on the left the random forest applied on the simulated data set with independent features and on the rightapplied on the one with high correlated features. On the first sight you cannot see a structure in the data distribution in the independent case. Furthermore, the data points fill out much more space in comparison (uniformly distributed) to the correlated case. Here one can see a clear postive correaltion between $X1$ and $X2$. For instance, if you permute one observation of $X1$ represented by the white arrow, the permute observation points is still near the data distribution in the independent case. However, in the correlated case the is absolut no other data points nearby. The data distribution of the training data lies on the diagonal. The region outside was not learned well enough by the random forest shown by the less rectangle lines in this area. So the random forest will predict the average of this area, which are vertical lines tring to predict the red area and horizontal lines tring to predict the blue area. The larger span of the quantile bands can be explained by the randomly permuting the data points. If the observation is still close to the data distribution after permuting it. The error made is less strong as in the example in the plot. So the change in error strongly depends on how far away the permuted data is from the real underlying data distribution. To sum up the extrapolation problem of the random forest is associated with the correlation intensity.

Quelle: Stop Permuting


```{r PFI02, message = FALSE, echo = FALSE, fig.height=6, fig.width=12, fig.cap= "PFI with different correlations of features 1 and 2 on SVM"}
library(ggplot2)
load("data/dsvmPFI.RData")

psvmerr <- ggplot(data = dsvmPFI, aes(x=features, y= importance, colour = Corr, ymin= minimp, ymax=maximp)) + 
  geom_point(fill = "white",size=0, shape=21 , 
             stroke= 2.5, show.legend = TRUE, position = position_dodge(width = 0.6)) +
  geom_errorbar(width=0.5, size=1, position = position_dodge(width = 0.6)) + 
  coord_flip() +
  scale_colour_manual(values=c("0" = "skyblue", "0.25" = "royalblue", "0.5"= "blue",
                               "0.75"="navy", "0.99" = "black"))+
  scale_fill_manual(values=c("0" = "skyblue", "0.25" = "royalblue", "0.5"= "blue",
                             "0.75"="navy", "0.99" = "black"))+
  theme(plot.subtitle = element_text(size = 9), text = element_text(size = 14), legend.position="bottom") +
  labs(y = "PFI (Loss: MSE)", x= "")

```

```{r PFIrank02, message = FALSE, echo = FALSE, fig.height=6, fig.width= 8, fig.cap= "PFI with different correlations of features 1 and 2 on SVM"}
library(ggplot2)
load("data/drfPFI.RData")

psvmrank01 <- ggplot(dsvmPFI, aes(x=averagerank , y=Corr, colour = features, group= features)) +
  geom_point(size=2)+
  geom_path(aes(group=features), size=1)+
  coord_flip() +
  scale_colour_manual(values = c("Uninf" = "#999999", "X1" = "darkred", "X2"= "red",
                               "X3"="#006600", "X4" = "#33CC33"))+
  scale_x_reverse()+
  geom_vline(xintercept = 2.5, linetype="dashed")+
  theme(legend.position="bottom", plot.subtitle = element_text(size = 9), text = element_text(size = 14))

```





```{r arrange02, message = FALSE, echo = FALSE, fig.height=6, fig.width=10, fig.cap= "PFI with different correlations of features 1 and 2 on SVM"}
library(ggpubr)
ggarrange(psvmerr, psvmrank01 , ncol=2, legend = "bottom", widths = c(2, 1))

```

The next Figure \@ref(fig:arrange02) demonstrates the application of the support vector maschines








```{r PFIlm, message = FALSE, echo = FALSE ,fig.height=6, fig.width=12, fig.cap="PFI with different correlations of features 1 and 2 on a linear model"}
library(ggplot2)
load("data/dlmPFI.RData")

plmerr <- ggplot(data = dlmPFI, aes(x=features, y= importance, colour = Corr, ymin= minimp, ymax=maximp)) + 
  geom_point(fill = "white",size=0, shape=21 , 
             stroke= 2.5, show.legend = TRUE, position = position_dodge(width = 0.5)) +
  geom_errorbar(width=0.5, size=1, position = position_dodge(width = 0.5)) + 
  coord_flip() +
  scale_colour_manual(values=c("0" = "skyblue", "0.25" = "royalblue", "0.5"= "blue",
                               "0.75"="navy", "0.99" = "black"))+
  scale_fill_manual(values=c("0" = "skyblue", "0.25" = "royalblue", "0.5"= "blue",
                             "0.75"="navy", "0.99" = "black"))+
  theme(plot.subtitle = element_text(size = 10)) +
  labs(y = "PFI (Loss: MSE)", x= "") + 
  theme(text = element_text(size = 16))

```


```{r PFIrank03, message = FALSE, echo = FALSE, fig.height=6, fig.width= 8, fig.cap= "PFI with different correlations of features 1 and 2 on SVM"}
library(ggplot2)
load("data/drfPFI.RData")

plmrank01 <- ggplot(drfPFI, aes(x=averagerank , y=Corr, colour = features, group= features)) +
  geom_point()+
  geom_path(aes(group=features))+
  coord_flip() +
  scale_colour_manual(values = c("Uninf" = "#999999", "X1" = "darkred", "X2"= "red",
                               "X3"="#33CC00", "X4" = "#33CC33"))+
  scale_x_reverse()+
  geom_vline(xintercept = 2.5, linetype="dashed")+
  theme(legend.position="bottom")

```



```{r arrange03, message = FALSE, echo = FALSE, fig.height=6, fig.width=10, fig.cap= "PFI with different correlations of features 1 and 2 on a linear model"}
library(ggpubr)
ggarrange(plmerr, plmrank01 , ncol=2, legend = "bottom")

```




















```{r LOCO01, message = FALSE,echo = FALSE , fig.height=6, fig.width=12, fig.cap= "LOCO Feature Importance with different kind of correlation intensity on a random forest model"}
library(ggplot2)
load("data/drfLOCO.RData")
#Plot:
plocoerr <- ggplot(data = drfLOCO, aes(x=features, y= importance, colour = Corr, ymin= minimp, ymax=maximp)) + 
  geom_point(fill = "white",size=0, shape=21 , 
             stroke= 2.5, show.legend = TRUE, position = position_dodge(width = 0.5)) +
  geom_errorbar(width=0.5, size=1, position = position_dodge(width = 0.5)) + 
  coord_flip() +
  scale_colour_manual(values=c("0" = "skyblue", "0.25" = "royalblue", "0.5"= "blue",
                               "0.75"="navy", "0.99" = "black"))+
  scale_fill_manual(values=c("0" = "skyblue", "0.25" = "royalblue", "0.5"= "blue",
                             "0.75"="navy", "0.99" = "black"))+
  theme(plot.subtitle = element_text(size = 10)) +
  labs(y = "LOCO (Loss: MSE)", x= "") + 
  theme(text = element_text(size = 16))
```


```{r LOCOrank01, message = FALSE, echo = FALSE, fig.height=6, fig.width= 8, fig.cap= "PFI with different correlations of features 1 and 2 on SVM"}
library(ggplot2)
load("data/drfLOCO.RData")

plocorank01 <- ggplot(drfLOCO, aes(x=averagerank , y=Corr, colour = features, group= features)) +
  geom_point()+
  geom_path(aes(group=features))+
  coord_flip() +
  scale_colour_manual(values = c("Uninf" = "#999999", "X1" = "darkred", "X2"= "red",
                               "X3"="#33CC00", "X4" = "#33CC33"))+
  scale_x_reverse()+
  geom_vline(xintercept = 2.5, linetype="dashed")+
  theme(legend.position="bottom")
```



```{r arrange04, message = FALSE, echo = FALSE, fig.height=6, fig.width=10, fig.cap= "PFI with different correlations of features 1 and 2 on SVM"}
library(ggpubr)
ggarrange(plocoerr, plocorank01 , ncol=2, legend = "bottom")

```








```{r LOCOsvm, message = FALSE,echo = FALSE , fig.height=6, fig.width=12, fig.cap= "LOCO Feature Importance with different kind of correlation intensity on SVM"}
library(ggplot2)
load("data/dsvmLOCO.RData")
#Plot:
plocosvmerr <- ggplot(data = dsvmLOCO, aes(x=features, y= importance, colour = Corr, ymin= minimp, ymax=maximp)) + 
  geom_point(fill = "white",size=0, shape=21 , 
             stroke= 2.5, show.legend = TRUE, position = position_dodge(width = 0.5)) +
  geom_errorbar(width=0.5, size=1, position = position_dodge(width = 0.5)) + 
  coord_flip() +
  scale_colour_manual(values=c("0" = "skyblue", "0.25" = "royalblue", "0.5"= "blue",
                               "0.75"="navy", "0.99" = "black"))+
  scale_fill_manual(values=c("0" = "skyblue", "0.25" = "royalblue", "0.5"= "blue",
                             "0.75"="navy", "0.99" = "black"))+
  theme(plot.subtitle = element_text(size = 10)) +
  labs(y = "LOCO (Loss: MSE)", x= "") + 
  theme(text = element_text(size = 16))
```

```{r LOCOrank02, message = FALSE, echo = FALSE ,fig.height=6, fig.width=12, fig.cap="LOCO Feature Importance with different kind of correlation intensity on a linear model"}

load("data/dsvmLOCO.RData")

plocorank02 <- ggplot(dsvmLOCO, aes(x=averagerank , y=Corr, colour = features, group= features)) +
  geom_point()+
  geom_path(aes(group=features))+
  coord_flip() +
  scale_colour_manual(values = c("Uninf" = "#999999", "X1" = "darkred", "X2"= "red",
                               "X3"="#33CC00", "X4" = "#33CC33"))+
  scale_x_reverse()+
  geom_vline(xintercept = 2.5, linetype="dashed")+
  theme(legend.position="bottom")
```



```{r arrange05, message = FALSE, echo = FALSE, fig.height=6, fig.width=10, fig.cap= "PFI with different correlations of features 1 and 2 on SVM"}
library(ggpubr)
ggarrange(plocosvmerr, plocorank02 , ncol=2, legend = "bottom")

```





```{r LOCOlm, message = FALSE, echo = FALSE ,fig.height=6, fig.width=12, fig.cap="LOCO Feature Importance with different kind of correlation intensity on a linear model"}
library(ggplot2)
load("data/dlmLOCO.RData")

#Plot:
plocolmerr <- ggplot(data = dlmLOCO, aes(x=features, y= importance, colour = Corr, ymin= minimp, ymax=maximp)) +
  geom_point(fill = "white",size=0, shape=21 , 
             stroke= 2.5, show.legend = TRUE, position = position_dodge(width = 0.5)) +
  geom_errorbar(width=0.5, size=1, position = position_dodge(width = 0.5)) + 
  coord_flip() +
  scale_colour_manual(values=c("0" = "skyblue", "0.25" = "royalblue", "0.5"= "blue",
                               "0.75"="navy", "0.99" = "black"))+
  scale_fill_manual(values=c("0" = "skyblue", "0.25" = "royalblue", "0.5"= "blue",
                             "0.75"="navy", "0.99" = "black"))+
  theme(plot.subtitle = element_text(size = 10)) +
  labs(y = "LOCO (Loss: MSE)", x= "") + 
  theme(text = element_text(size = 16))
```


```{r LOCOrank03, message = FALSE, echo = FALSE ,fig.height=6, fig.width=12, fig.cap="LOCO Feature Importance with different kind of correlation intensity on a linear model"}

load("data/dlmLOCO.RData")

plocorank03 <- ggplot(dlmLOCO, aes(x=averagerank , y=Corr, colour = features, group= features)) +
  geom_point()+
  geom_path(aes(group=features))+
  coord_flip() +
  scale_colour_manual(values = c("Uninf" = "#999999", "X1" = "darkred", "X2"= "red",
                               "X3"="#33CC00", "X4" = "#33CC33"))+
  scale_x_reverse()+
  geom_vline(xintercept = 2.5, linetype="dashed")+
  theme(legend.position="bottom")
```



```{r arrange06, message = FALSE, echo = FALSE, fig.height=6, fig.width=10, fig.cap= "PFI with different correlations of features 1 and 2 on SVM"}
library(ggpubr)
ggarrange(plocolmerr, plocorank03 , ncol=2, legend = "bottom")

```













**2) Linear Dependence with bigger influence factors:**

The second scenario setting the dependence of the features $X_i$ on the target value $y$ is also a linear one, but with a small change in the coefficient of $X4$ from $1$ to $1.2$: 


$$
y_{i} = x_{i1}+x_{i2}+x_{i3}+1.2x_{i4}+\epsilon_{i}
$$


















**3) Nonlinear Dependence:**

In the third scenario there is no pure linear relationship between the target value $y$ and the features $X_{i}$. $X1$ and $X3$ are pluged into the sine function: 



$$
y_{i} = sin(x_{i1})+x_{i2}+sin(x_{i3})+x_{i4}+\epsilon_{i}
$$





### Real Data



## Prevention of Correlation Problems

In summary, when features of a given data set are correlated, feature importance measures like LOCO or PFI can be strongly misleading. Thus, a check for correlated features before a usage of these two methods is recommended or in other words even necessary to have a credible interpretation. 

* Conditional variable importance (Strobl 2008)
* Stop Permuting features 2019

